# 5. Фронт-энд для разработки игр Klaytn Addition
 
## 5.1 Настройки


Теперь, когда вы создали контракт, который будет использоваться для BApp в предыдущих классах, давайте сделаем предварительную разработку.
Сначала давайте приступим к базовой настройке.
В этом уроке я скачаю node.js, npm, инфраструктуру Truffle и код Visual Studio.
Node.js - это серверная JavaScript-платформа, которая нам реально нужна для нашего BApp.
Npm устанавливается вместе с node.js, который необходим для загрузки инструментов и библиотек во время разработки.
Платформа Truffle, которую мы будем устанавливать, также должна быть загружена через npm.
Если у вас уже установлены node.js и npm, проверьте версию и пропустите этот раздел, если node.js версии 8 или выше, а npm версии 5 или выше.


Пожалуйста, зайдите на https://nodejs.org и загрузите 10.15.3 LTS. Затем установите его.
Я уже сделал это, и поэтому я пропускаю этот шаг.
После установки мы проверим, правильно ли установлен node.js в PowerShell.
Введите Node-v и проверьте версию. а также проверьте Npm. Npm -v, да, он установлен правильно.


Наконец, я установлю Truffle.
Truffle - это фреймворк, который помогает вам легко развивать BApp.
Truffle позволяет вам компилировать, тестировать и развертывать смарт контракты.
Это очень популярный фреймворк.
Версия Truffle недавно была обновлена до 5.
Однако, поскольку Klaytn был разработан для версии 4, я буду использовать версию Truffle 4.
Если у вас уже установлена версия 4 или менее или 5, сначала необходимо удалить ее.
Удалите ее, введя `npm uninstall -g truffle` в PowerShell.
Теперь вставьте «npm install -g truffle@4.1.15», после установки вы получите версию 4.


Если вы все загрузили, проверьте версию с помощью команды версии Truffle.
Это версия 4.1.15, а компилятор solidity  - версия 0.4.25.
solidity  - это язык программирования, с помощью которого вы можете писать умные контракты. Наконец, давайте загрузим лучший редактор кода,  Visual Studio. Зайдите на https://code.visualstudio.com/ для загрузки под Windows.
Я скачал его заранее. Так что я тоже пропущу эту часть.
Если вы загрузили его, пожалуйста, установите и запустите.
Код Visual Studio поддерживает кроссплатформенность, поэтому работает на Linux, Windows, Mac и включает ряд полезных функций, таких как поддержка отладки, управление git, подсветка синтаксиса и многое другое.




Теперь нажмите на вкладку расширения, чтобы установить расширение для поддержки языка solidity. Пожалуйста, введите «solidity» и выберите тот, что сверху.
Нажмите Установить. Это расширение обеспечивает цветовую подсветку для каждого элемента грамматики solidity и позволяет вам компилировать.
Установка завершена. Я закончил сеанс настройки, который необходим для фронт-энд разработки.
 
 
## 5.2 Скачать шаблон
 
 
Давайте скачаем boiler plate, базовый шаблон для разработки.
Klaytn  говорит, что BApp может быть разработан в рамках Truffle.
 В Truffle есть несколько мест, где вы можете скачать стандартные шаблоны для вашей разработки BApp.
 Это называется Truffle Box.
«Https://truffleframework.com/boxes»
Если Вы зашли по ссылке, Вы можете увидеть шаблоны.
 Например, если вы хотите разработать BApp с использованием Angular или React, вы можете загрузить подходящий вам шаблон.
Однако загруженные здесь шаблоны специализируются на приложении Ethereum, поэтому вам необходимо загрузить их и стереть внутренние части.
 Затем Вы должны настроить шаблон для Klaytn.
Это не сложная часть, но я заранее скачал шаблон под названием webpack
и изменил его «Klaytn way», чтобы вписаться в нашу лекцию.
 Я загрузил его на Github, чтобы вы могли скачать его.
 Для справки, мы продолжим работу с нативным JavaScript и JQuery.
 Даже если вы новичок в этом, вы можете легко следовать за нами
 
Откройте PowerShell и выполните команду git clone в «https://github.com/kkagill/addition-game-starter.git» в том месте, куда вы хотите его скачать.
Я все это уже скачал.
Сделайте «Cd addition-game-starter», чтобы войти в патч. Теперь код. Давайте посмотрим на структуру, вставив «code».
Позвольте мне начать сверху вниз.
В папке «Contracts » хранятся файлы контрактов на solidity
У нас есть файл контракта «Addition Game», который мы создали, и у нас есть контракт под названием «migrations», который позволит вам запускать файлы сценариев в папке миграций ниже, когда вы развертываете свой смарт-контракт.
Это необходимый файл для развертывания контракта, поэтому вы никогда не должны его удалять.
 
Далее, файлы сценариев в папке `migrations` содержат логику, используемую в процессе развертывания.
Если вы видите этот файл, он импортирует файл контракта миграции и развертывает его содержимое на ноде Klaytn.
Внутри папки src я настроил структуру, которая состоит из внешнего интерфейса BApp. Файл index.html будет отвечать за первичное представление.
Я загрузил jquery и bootstrap для использования в BApp вместе с cdn и заранее добавил часть css ниже.
 
Файл Index.js похож на движок - он выполняет функции.
Мы уже определили имена функций, которые мы напишем в будущем.
Переменная внизу - это переменная конфигурации, которая показывает счетчик при загрузке. Это не самая важная часть, поэтому я добавил ее заранее.
В package.json вы добавляете необходимые зависимости через npm.
Важно то, что вы загрузите файл библиотеки, который позволит вам общаться с caver-js, блокчейном Klaytn.
Это похоже на web3 js Ethereum.
Truffle.js отвечает за настройку среды.
Через Truffle вы будете определять, в каких сетях будут внедряться интеллектуальные контракты.
Я расскажу об этом в следующей лекции.
Webpack оптимизирует файлы и обнаруживает изменения в коде и отображает изменения в браузере, не обновляя страницы.
До сих пор я загружал и объяснял стартовый шаблон для создания приложения игры Klaytn BApp.
 



## 5.3 Развертывание смартконтракта на Baobab 1
 
Теперь давайте развернем смартконтракт AdditionGame, который мы формирем в тестовой сети Baobab. Прежде чем мы начнем, мы запустим команду npm install в терминале и установим необходимые зависимости для BApp.
Если вы не видите терминал ниже, выберите новый терминал на вкладке Терминал.
Теперь запустите команду установки npm.
Это займет некоторое время. По завершении создается папка с именем «node_modules» и установка завершается.
 
 
 
Сначала давайте создадим новый файл в папке миграций.
Щелкните правой кнопкой мыши папку «Миграция» и выберите «Новый файл». Установите имя  «2_deploy_contracts.js», и мы добавим логику для развертывания контракта AdditionGame на ноде.
 
Перейдите к файлу `Initial migrations`, скопируйте и вставьте все коды.
Пожалуйста, измените его на «importing the AdditionGame contract».
Замените часть, которая будет развернута, на `AdditionGame`. Пока основная логика для развертывания закончена.
Тем не менее, я напишу определенный код в некоторые файлы в BApp для хранения информации, которую я получаю в процессе развертывания. Позже это может быть очень полезно для создания экземпляров контрактов с этой информацией.
deployer.deploy (AdditionGame)
 
Приложение развертывает контракт AdditionGame, и через `then` мы получаем  данные json.
И в них
 
if (AdditionGame._json) {
 
Если вы получили данные json игры Additions, вы сохраните их в файл через модуль файловой системы.
Чтобы сделать это, вы должны сначала импортировать его.
Добавьте `const fs = require ('fs')` сверху.
Хорошо, тогда я создам два файла. В этих файлах мы можем сохранить Abi и адрес контракта. Щелкните правой кнопкой мыши в любом месте фона и назовите новый файл «deployedABI».
Создайте еще один и назовите его «deployedAddress».
Теперь мы будем использовать файловую систему для хранения их в каждом файле.
Во-первых, давайте создадим код, который хранит информацию abi.
Abi  - это контент, который может взаимодействовать между блокчейном и контрактом.
  	fs.writeFile(
    	'deployedABI',
    	JSON.stringify(AdditionGame._json.abi),
 
В файловой системе есть функция writeFile. Определите, какой файл записать, и зафиксируйте информацию abi, которую мы получили от json, и передайте ее аргументу. Наконец, мы обработаем ошибку.
 
    	(err) => {
      	if (err) throw err
      	console.log("파일에 ABI 입력 성공");
    	})
Если есть ошибка, удалите ее. Если нет, запишите журнал на консоли. Это сохраняет информацию abi развернутого контракта в файле deployedABI как литерал. Для продолжения я сохраню адрес развернутого контракта в файл.
fs.writeFile(
  	'deployedAddress',
  	AdditionGame.address,
  	(err) => {
    	if (err) throw err
    	console.log("파일에 주소 입력 성공");
	})
Если вы уже выполнили все этапы,  мы можем сохранять необходимую информацию в каждом файле сразу после каждого его развертывания. Я продолжу настраивать среду в truffle.js и разверну ее в следующей лекции.
 
 
 
## 5.4 Развертывание смартконтракта на Baobab 2
 
 
Наконец, вам нужно установить настройки. Вы должны решить, какую сеть вы собираетесь развернуть.
Перейдите в файл Truffle.js. Теперь работаем с этого момента. Во-первых, я импортирую библиотеку с именем `connect-privkey-to-provider.`
const PrivateKeyConnector = require ('connect-privkey-to-provider')
 
также создаем константу, называемую идентификатором сети.
 
const NETWORK_ID = '1001'
 
1001 means Baobab's unique network ID.
const GASLIMIT = '20000000'
 
Это предел газа для развертывания. Всего семь нулей.
const URL = `https://api.baobab.klaytn.net:8651`
 
Для UR я назначил адрес, где в настоящий момент работает полная нода Klaytn, в тестнете baobab. Наконец, нам нужна константа для хранения секретного ключа, поэтому мы получим секретный ключ учетной записи, которую мы создали ранее через Klaytn Wallet. Я говорил вам, ребята,  сохранить ваш секретный ключ. Я копирую и вставляю свой, который я сохранил в блокноте.
const PRIVATE_KEY = ''
 
 
Теперь давайте использовать эти настройки в module.exports.
module.exports = {
  networks: { 
	klaytn: {
  	provider: new PrivateKeyConnector(PRIVATE_KEY, URL),
  	network_id: NETWORK_ID,
  	gas: GASLIMIT,
  	gasPrice: null,
	}
  },
}
 
 Позвольте мне объяснить это в первую очередь. Я сказал, что мы будем использовать «Klaytn» для сетей.
Теперь мы укажем четыре варианта. Сначала вы указываете провайдера, который предоставляет узел Klaytn. Создайте экземпляр PrivateKeyConnector и передайте два аргумента.
Первый - передать секретный ключ моей учетной записи, а второй - сетевой адрес, на котором работает полный узел.
Это позволит мне подключиться к тестовой сети баобаба, используя мой секретный ключ.
Присвойте идентификатор сети и газ, и, наконец, цена на газ будет установлена на нулевое значение. Сеть Baobab автоматически установит цену на газ, поэтому мы передаем нулевое значение.
Да, сейчас я настроил свою среду для развертывания смартконтрактов. Это довольно просто. Теперь давайте развернем их. В терминале запустите `truffle deploy -network klaytn`. Да, контракт успешно развернут. Вы можете увидеть фразу подтверждения, в консоли.
 
 
 
Теперь, если вы посмотрите на файл deployedABI, увидите, что информация abi сохраняется. Перейдите к развернутому адресу и обратите внимание, что адрес развернутого контракта сохраняется. Все работает хорошо. Наконец, при развертывании создается папка с именем build. Внутри него есть папка "contracts", а два файла json находятся в папке contracts. Они называются артефактами. Каждый файл артефакта содержит информацию ABI соответствующего контракта, а также всю информацию, связанную с контрактом. ABI - это аббревиатура двоичного интерфейса приложения; мы ранее сохранили развернутый файл ABI в нем. В abi мы видим функции и переменные, записанные в формате json, который мы используем для контракта AdditionGame.
 
Проще говоря, при развертывании этого контракта в блокчейне abi гарантирует вызов функций в контракте и гарантирует, что данные будут возвращены в ожидаемом формате. Именно здесь вы определяете, как вы можете взаимодействовать с контрактом. Если пройти вниз, там есть сетевой раздел. 1001 - уникальный идентификатор сети Klaytn. Этот контракт в настоящее время размещен по этому адресу в тестовой сети Baobab.
 
 
truffle deploy –compile-all –reset –network klaytn
 
 
Наконец, если вы хотите повторно развернуть контракт на узле Klaytn, вы можете использовать эту команду. Например, когда нам нужно изменить договор, нам нужно повторно развернуть его на ноде. `truffle deploy -compile-all -reset -network – Klaytn`
компилировать все, перекомпилировать все контракты. Сброс принудительно запускает файлы сценариев в папке «Миграции». Запустите его, чтобы заново развернуть контракт на узле. Да. Успешно завершено. Откройте файл deployedAddress, и вы увидите, что адрес изменился. Я развернул Контракт в сети Klaytn Baobab, используя truffles.
 
 
 
 
 
## 5.5 Пользовательский интерфейс подтверждения аккаунта
 
 
Начните с входа в свою учетную запись, созданную с помощью кошелька Baobab.
У нас было два способа проверить наши аккаунты.
  Во-первых, вы можете использовать комбинацию файлов и паролей хранилища ключей, а во-вторых, проверить с помощью закрытого ключа.
Мы реализуем это, проверяя комбинацию файлов хранилища ключей и паролей.
Сначала я напишу HTML-код.
Перейдите в Index.html и добавьте фрагмент в тег body.
  <div class="container">
    <div class="row">
  	<div class="col-md-8 col-md-offset-2">
    	<h1 class="text-center">클레이튼(Klaytn)</h1>
    	<h3 class="text-center">속전속결 덧셈 게임</h1>
    	<h3 class="text-center">
      	<code>3초안에 맞출 시 0.1 KLAY 지급 이벤트</code> 
      	<button type="button"
              	class="btn btn-info pull-right"
              	id="login"
              	data-toggle="modal"
              	data-target="#loginModal">
              	로그인
      	</button>
      	<button type="button"
              	class="btn btn-info pull-right"
              	id="logout"
    	          style="display: none;"
              	onclick="App.handleLogout()">
              	로그아웃
      	</button>
    	</h3>        
    	<hr />
  	</div>
	</div>
  </div> 
 
 
 
Пожалуйста, остановите это видео сейчас и напишите этот код.
Очень простая настройка.
Классы в div используют начальную загрузку, чтобы интерфейс выглядел красиво.
 Я пропущу описание начальной загрузки.
Прежде всего, я выложил пояснительные фразы в верхней части.
Ниже мы добавили кнопки входа и выхода.
Когда я нажимаю на кнопку входа, система запускает модальное окно.
Когда я нажимаю кнопку выхода из системы, выполняется функция handleLogout.
Обратите внимание, что я установил кнопку выхода, она не появляется в css.
Давайте запустим приложение, и проверим, работает ли написанный нами код.
Запустите команду npm run dev на терминале.
Запустите Chrome и перейдите по адресу localhost: 8081.
Да, это не так красиво, но выглядит хорошо.
Теперь давайте создадим модальное окно, которое будет появляться при нажатии кнопки входа. ‘Https://bootstrapdocs.com/v3.3.6/docs/javascript/#modals’ Если вы зайдете на сайт начальной загрузки, вы можете получить модальный код.
Скопируйте эту часть и вернитесь в HTML-файл.
Я вставлю это за пределы div.
Теперь давайте изменим содержимое этого фрагмента.
Сначала установите для идентификатора div значение loginModal.
section.
  <div class="modal fade" tabindex="-1" role="dialog" id="loginModal">
 
Вам должно понравиться когда modal открывался при нажатии кнопки входа.
Он соответствует модальному значению атрибута data-target верхней кнопки входа в систему.
Далее мы изменим размер modal на меньший.
 
  <div class="modal-dialog modal-sm">
 
 
Удалить все модальные заголовки раздела.
Также удалите контент внутри модального тела.
Теперь добавьте часть, в которую можно загрузить файл хранилища ключей, и часть, где можно ввести пароль.
<div class="form-group">
   <label for="keystore">Keystore</label>
   <input type="file" id="keystore" onchange="App.handleImport()">
</div>
 
Установите тип ввода как файл и сделайте функцию handleimport для вызова в событии onchange.
  А ниже добавьте часть для пароля (비밀번호). 
 
Скопируйте и вставьте сверху.
<div class="form-group">
  <label for="input-password">비밀번호</label>
  <input type="password" class="form-control" id="input-password" onchange="App.handlePassword()">
   <p class="help-block" id="message"></p>
</div>
 
 
Если значение записано в окне ввода пароля, вызовите функцию handlePassword.
  И я добавил часть, которая будет отображаться в виде сообщения, когда проверка прошла успешно или произошла ошибка.
Наконец, измените`close` на `닫기(close)` и измените `safe changes` на `submission.`
<button type="button" class="btn btn-default" data-dismiss="modal">닫기</button>
        	<button type="button" class="btn btn-primary" id="submit" onclick="App.handleLogin()">제출</button>
 
Добавьте атрибут id и разрешите вызывать функцию handleLogin при нажатии.
Да, сейчас я проверю, что завершенный код работает нормально в приложении.
Нажмите кнопку входа.
Что ж, теперь модал работает, и у вас есть возможность выбрать файл и ввести пароль.
Вот, я создал пользовательский интерфейс для проверки учетных записей.
 
 
## 5.6 Логика проверки аккаунта (проверка хранилища ключей)
 
 
 
Теперь, когда мы создали интерфейс, показанный выше, давайте реализуем логику его работы.
  В Index.js в константе есть различные функции, которые называются App.
И, наконец, когда вы спуститесь вниз, вы увидите, что при загрузке страницы запускается функция запуска, которая существует в константе приложения.
Поэтому мы реализуем функцию start, но перед этим нам нужно загрузить библиотеку caver.js для связи с блокчейном Klaytn и создать ее экземпляр, чтобы ее можно было использовать для BApp.
Импортируйте Caver из "caver-js";
 
Вверху импортируйте caver.js.
Процесс создает одну константу для настройки среды.
 
const config = {
  rpcURL: 'https://api.baobab.klaytn.net:8651'
}
 
 
В конфиге есть rpcURL.
Мы определили, к какому узлу Klaytn подключаться и использовать.
Я сказал, что это baobab тестнет.
Наконец, мы создадим константу, которая создает экземпляр rpcURL, передавая его конструктору Caver.
const cav = new Caver(config.rpcURL);
 
 
Работа над созданием завершена, и эта константа теперь доступна в приложении.
  Теперь вам нужно запустить функцию, но перед этим, в функции запуска, вы должны сначала убедиться, была ли учетная запись проверена в течение сеанса.
Тем не менее, я оставлю эту часть напопозже, потому что мы будем использовать сессию в более поздней лекции, так что пока оставьте функцию запуска пустой.
Давайте сначала реализуем функцию handleImport.
  Мы должны быть в состоянии нажать на кнопку входа и выбрать файл хранилища ключей после того, как появится модальное окно.
Однако этот файл должен быть проверен, является ли он действительным файлом хранилища ключей или нет.
Давайте сделаем это в функции handleimport.
Сначала мы создаем объект FileReader и помещаем его в константу.
const fileReader = new FileReader();
 
 
Используйте функцию readAsText, чтобы прочитать выбранный файл.
fileReader.readAsText(event.target.files[0]);
 
 
event.target.files, эта часть показывает файл, который мы выбрали.
Когда выполнение readAsText завершено, происходит событие onload FileReader.
fileReader.onload = (event) => {  	
  
}
 
Событие, полученное обратным вызовом, другими словами, содержимое файла, теперь можно использовать в этом блоке кода.
Содержимое этого файла будет проверено, является ли он действительным файлом хранилища ключей.
Сначала добавьте блок try catch.
 
  try {
   	
  } catch (event) {
   	
  }
 
 
Теперь мы проверим if-предложение, является ли содержимое файла допустимым или нет, другими словами, является ли это фактическим файлом хранилища ключей.
if (!this.checkValidKeystore(event.target.result)) {
 
}
 
 
Я передал содержимое файла, который мы читаем, функции checkValidKeystore в качестве аргумента.
  Теперь давайте украсим функцию checkValidKeystore.
Эта функция принимает хранилище ключей в качестве аргумента и получает файл.
И файл хранилища ключей, который я получил, является файлом json.
Я изменю его на объект Javascript, чтобы использовать свойства этого файла json в качестве переменных.
	const parsedKeystore = JSON.parse(keystore);
 
 
Я использовал функцию синтаксического анализа json для анализа содержимого файла хранилища ключей, преобразования его в объект и сохранения его в константе.
Что нам делать дальше?
Убедитесь, что свойства, необходимые для вашей конфигурации хранилища ключей, введены правильно.
Давайте посмотрим на файл хранилища ключей и посмотрим, что нам нужно.
Основными элементами конфигурации хранилища ключей являются версия, идентификатор, адрес и криптография.
Без этих четырех полей файл хранилища ключей не может быть файлом хранилища ключей.
Итак, я проверю это через код.
const isValidKeystore = parsedKeystore.version &&
  	parsedKeystore.id &&
  	parsedKeystore.address &&
  	parsedKeystore.crypto;
 
 
В финале, необходимо получить эту константу.
return isValidKeystore;
 
 
Я снова проверил, является ли файл, который я только что импортировал, действительным файлом хранилища ключей.
Если нет, то сообщение показывает, что оно недействительно и завершает функцию.
$('#message').text('유효하지 않은 keystore 파일입니다.');
return;
 
Если он прошел проверку, мы сохраним содержимое файла хранилища ключей в глобальной переменной.
Во-первых, нам нужно создать глобальную переменную. Создайте ее в функции запуска
 
auth: {
	accessType: 'keystore',
	keystore: '',
	password: ''
  },
 
 
В объекте Auth есть три поля.
  AccessType - это метод проверки, который имеет тип хранилища ключей и тип закрытого ключа.
Мы продолжаем с типом хранилища ключей.
Поле Keystore хранит все содержимое файла хранилища ключей.
  Наконец, password - это поле, содержащее пароль, который будет объединен с файлом хранилища ключей.
Если мы вернемся к функции и пройдем проверку,
this.auth.keystore = event.target.result;
 
 
отправьте все содержимое загруженного файла в поле хранилища ключей созданной нами переменной auth.
После этого отправьте сообщение о том, что процесс успешен.
$('#message').text('keystore 통과. 비밀번호를 입력하세요.');
 
Разрешите сразу ввести пароль в поле пароля.
 
document.querySelector('#input-password').focus();
 
Наконец, при чтении файла, если есть ошибка, отправьте сообщение об ошибке в блоке catch и завершите функцию.
$('#message').text('유효하지 않은 keystore 파일입니다.');
return;
 
 
Да, пока функция Handleimport реализована хорошо.
Давайте проверим ее сейчас. Выберите файл хранилища ключей.
Будет отображено сообщение о пропуске, и фокус будет перемещен в ту часть, где можно ввести пароль.
Чтобы проверить иной случай, давайте выберем любой случайный файл.
Хорошо, сообщение об ошибке генерируется.
Работает хорошо.
Теперь давайте создадим функцию, которая сохраняет пароль в глобальной переменной, когда мы вводим пароль.
Это будет очень просто.
Если вы переходите на html, функция handlepassword вызывается при вводе пароля.
Затем, в функции handlepassword,
this.auth.password = event.target.value;
 
Получите значение пароля через событие html onchange, а затем присвойте его полю пароля глобальной переменной auth.
  Это было очень просто.
Итак я сделал файл проверки файла хранилища ключей.
  В следующей лекции я создам секретный ключ и добавлю информацию о своей учетной записи в кошелек.
 
## 5.7 Проверка аккаунта (интеграция кошелька)
 

Мы закончили лекцию для получения файла хранилища ключей и ввода пароля,
Теперь мы проверим, была ли учетная запись успешно подтверждена, когда мы отправляем эту информацию на ноду baobab.
Перед этим я заменю http в rpcURL на https.
Посмотрите на Index.html.
Когда я нажимаю кнопку отправки, она вызывает функцию handlelogin.
Итак, давайте реализуем функцию.
Сначала убедитесь, что accesstype является хранилищем ключей.
if (this.auth.accessType === 'keystore') { 
}

Причина, по которой мы пишем оператор if, заключается в том, что при проверке учетной записи мы используем хранилище ключей или закрытый ключ.
Сейчас мы используем только хранилище ключей.
Однако я добавил эти операторы if, чтобы, когда вы хотите использовать закрытый ключ для проверки,
Вы можете использовать if и, пожалуйста, добавьте оператор `try catch` ниже.
 
 
try {       
} catch (e) 
}

Настало время, наконец, использовать Caver.
Я задам вам задачу.
Что мы можем иметь на комбинации файла хранилища ключей и пароля?
Если вы хорошо запоминаете, вы можете ответить сразу.
Да, вы можете получить свой закрытый ключ.
Этот секретный ключ позволяет вам создать экземпляр кошелька.
Поэтому первое, что вам нужно сделать, это получить свой секретный ключ через файл хранилища ключей и пароль.
const privateKey = cav.klay.accounts.decrypt(this.auth.keystore, this.auth.password).privateKey;

Вы можете использовать функцию расшифровки через компоненты учетных записей caver.
Вы можете это расшифровать.
Если вы расшифровали его, вы можете вернуть расшифрованный объект учетной записи, передав в качестве аргументов содержимое файла хранилища ключей и пароль.
В объекте есть различные компоненты, и среди них мы получаем закрытый ключ и сохраняем его в константе.
Если при расшифровке возникнет ошибка, будет отправлено сообщение.
$('#message').text('비밀번호가 일치하지 않습니다.');
$(‘#message’).text(‘password is not matched.’);
 
Если ошибки нет, он создаст экземпляр кошелька через ваш секретный ключ.
 
this.integrateWallet(privateKey);



Передайте закрытый ключ в функцию integratewallet.
Теперь перейдите к функции integratewallet.
Здесь мы добавляем код, который получает экземпляр кошелька с помощью privatekey.
 
const walletInstance = cav.klay.accounts.privateKeyToAccount(privateKey);
 

Этот кошелек содержит информацию о учетной записи.
Затем добавьте этот экземпляр в мой кошелек.
cav.klay.accounts.wallet.add(walletInstance)
 

Если вы добавите мою учетную запись в кошелек Caver,
Вы можете легко вызвать информацию о своей учетной записи через  Caver при создании транзакции в будущем.
Следующим шагом является сохранение экземпляра кошелька в хранилище сеанса.
SessionStorage будет хранить экземпляр кошелька в области хранения в веб-браузере до тех пор, пока вкладка не будет закрыта или веб-браузер не будет отключен.
sessionStorage.setItem('walletInstance', JSON.stringify(walletInstance))
 
 

SetItem получает значение ключа в виде пары.
Первый параметр является ключем, а второй параметр является значением.
Итак, мне нужно будет загрузить информацию о моей учетной записи в сеанс.
Когда вы вызываете walletInstance со значением ключа, значение, сохраненное в паре, загружается автоматически.
Причиной использования sessionStorage является сохранение учетной записи в системе.
Потому что информация моего аккаунта, хранящаяся в моем кошельке, исчезает, когда я захожу на другой сайт или страница обновляет эту информацию.
Тем не менее, если вы сохраните в хранилище сеанса,
информация о вашей учетной записи будет сохраняться, даже если вы на некоторое время посетите другой сайт, а затем вернетесь к нему или обновите страницу.
Поэтому я буду реализовывать сеанс экземпляра кошелька в функции start позже и держать его в системе.
Прямо сейчас мне нужно обновить интерфейс.
Теперь, когда мы завершили проверку аккаунта через integrateWallet, нам нужно соответствующим образом изменить интерфейс.
this.changeUI(walletInstance);  

Я отправляю экземпляр кошелька в функцию changeUI.
Так что же нам делать с функцией changeUI?
Закройте свой модал.
$('#loginModal').modal('hide');
 

Также, скройте кнопку входа.
$("#login").hide();
 
Кроме того, измените кнопку выхода, которую вы спрятали ранее.
 
$('#logout').show();

И поскольку вы вошли в систему, я хочу, чтобы адрес моей учетной записи был виден.
$('#address').append('<br>' + '<p>' + '내 계정 주소: ' + walletInstance.address + '</p>');   
 

Этот код говорит мне, что он показывает адрес учетной записи в HTML, где атрибут id является адресом.
Я пойду в index.html и добавлю один div.
  <div class="text-center" id="address"></div>    

Да, вы можете увидеть адрес моей учетной записи в этом месте.
Я сделаю это здесь.
Теперь давайте проверим.
Нажмите кнопку «Вход» и откройте файл хранилища ключей.
Если вы введете свой пароль и нажмете кнопку отправки, ваша учетная запись будет подтверждена и появится кнопка выхода из системы.
Ниже вы можете увидеть адрес учетной записи.
Наконец, давайте реализуем функцию выхода из системы.
Перейдите на Index.html.
Обратите внимание, что когда я нажимаю кнопку выхода из системы, я вызываю функцию handlelogout.
Перехожу туда.
Здесь мы будем вызывать функцию с именем removeWallet.
this.removeWallet();
 

С помощью этой функции мы очистим кошелек и сессионное хранилище.
Перейдите к функции removeWallet и добавьте этот код.
cav.klay.accounts.wallet.clear();
 
Это процесс удаления моего экземпляра кошелька: информация об учетной записи, которая была добавлена в кошелек.
Затем очистите сеанс.
 
sessionStorage.removeItem('walletInstance');

Когда вы удаляете его, просто введите значение ключа.
Как результат, он вызывает функцию сброса и завершается.
this.reset();
 

Эта функция сброса просто инициализирует глобальную переменную auth.
Можно перейти к функции сброса и инициализировать авторизацию.
this.auth = {
      keystore: '',
      password: ''
    };
 

Существует также accesstype в Auth.
Но вам не нужно удалять accesstype, потому что это все равно будет хранилище ключей.
Вместо этого, после того мы вошли в систему, значение будет введено в поля хранилища ключей и пароля.
Я хочу выйти и безопасно стереть все.
Вернитесь к функции handleLogout и вставьте код, который обновляет страницу, и завершите ее.
Причиной обновления является возврат в исходное состояние интерфейса.
location.reload();
 

Теперь давайте сделаем тест и закончим.
При нажатии кнопки «Выход» информация об учетной записи исчезнет, и вы вернетесь к экрану инициализации после обновления.
Теперь, когда вы завершили логику проверки аккаунта,
давайте закончим раздел, который поддерживает проверку аккаунта через хранилище сеансов в следующем уроке.
 
 
## 5.8 Сеанс аккаунта

Давайте посмотрим, что произойдет, когда мы войдем и обновим страницу.
Нажмите кнопку входа и выберите файл хранилища ключей.
В этом состоянии нажмите F5, с целью обновить страницу.
Все будет сброшено.
Было бы хорошо, если бы я продолжал входить в систему.
Как мне это сделать?
Если нам удалось войти в систему, мы сохранили информацию о хранилище учетной записи в хранилище сеанса.
Я буду использовать этот факт сейчас.
Первая функция, которая загружается при запуске BApp, - это функция запуска.
Здесь я получаю информацию об учетной записи, хранящуюся в хранилище сеансов.
Итак, давайте перейдем к функции запуска,
const walletFromSession = sessionStorage.getItem ('walletInstance');
 

Если вы используете getItem и передаете значение ключа, значение, сохраненное в паре, извлекается и сохраняется в константе.
Я сохранил свой экземпляр кошелька.
После этого убедитесь, что walletFromSession содержит значение.
if (walletFromSession) {
 
}
 

If there is a value, create a try catch.
try { 
     
} catch (e) {
 
  }
 

Затем добавьте информацию о своей учетной записи обратно в кошелек.
cav.klay.accounts.wallet.add(JSON.parse(walletFromSession));

Когда страница обновляется или повторно посещается, информация о существующей учетной записи, которая была добавлена в кошелек, стирается, поэтому я добавляю ее обратно через сеанс.
Обновите пользовательский интерфейс, чтобы показать, что вы вошли как следующий участник.
  this.changeUI(JSON.parse(walletFromSession));
 

Появится кнопка выхода и покажет адрес вашей учетной записи.
Наконец, если значение в sessionStorage не является допустимым экземпляром Wallet, оно переходит к оператору catch.
Затем удалите кошелек в хранилище сеансов.
sessionStorage.removeItem('walletInstance');
 
Готово.
Теперь давайте проверим.
Когда вы обновляетесь, страница продолжает входить в систему, не возвращаясь в состояние инициализации.
До сих пор мы реализовали часть ведения проверки аккаунта.
 
 
 
 
## 5.9 Перевод KLAY через контракт (депозит)
 
 
Теперь я отправлю KLAY на контракт, используя учетную запись оператора.
Сначала давайте создадим пользовательский интерфейс.
Вы можете создать его в строке класса div.
 
 
<br />     
 
    <div class="row text-center">
      <div class="col-md-2 col-md-offset-5">
        <div id="owner" style="display: none;">
          <hr />
          <label>컨트랙에 KLAY 보내기</label>
          <div class="input-group">             
            <input type="number" class="form-control" id="amount" />
            <span class="input-group-btn">
              <button type="button" class="btn btn-default" onclick="App.deposit()">송금</button>
            </span>
          </div>
        </div>
      </div>       
    </div>
 

Пожалуйста, посмотрите видео и добавьте эту часть.
Я объясню вкратце.
Я настроил часть пользовательского интерфейса для отправки денег на контракт, невидимый через CSS.
Мы настроили функцию запуска депозита, когда вводим сумму и нажимаем кнопку перевода.
Теперь перейдем к функции депозита и реализуем ее.
 
Я объясню, как реализовать это в первую очередь.
Перевод Klay на контракт возможен только с аккаунта владельца.
Это возможно только с аккаунта лица, которое развернуло Контракт.
Другими словами, только организатор этого события может отправить Klay.
Если мы используем учетную запись владельца, мы получим доступ к функции депозита в договоре и переведем KLAY.
Процесс очень прост.
Сначала мы создадим пример, чтобы получить доступ к развернутому нами контракту.
Когда вы создаете экземпляр контракта, вам нужна информация abi и адрес развернутого контракта.
Под константами в верхней части,
const agContract = new cav.klay.Contract(DEPLOYED_ABI, DEPLOYED_ADDRESS);

Здесь deployed_abi и deployed_address являются глобальными константами, которые могут использоваться в BApp.
После развертывания контракта мы сохраняем информацию в файле deployedabi и файле deployedaddreess.
Установите его в веб-пакете, чтобы мы могли прочитать эту информацию и использовать ее как глобальную константу.
Если вы перейдете в файл Webpack.config.js, там будет аннотированный раздел.
Сделайте это сейчас.
Во время компиляции в веб-пакетах запустите эту часть, чтобы установить глобальные константы, называемые развернутым адресом и развернутым abi.
 
Проще говоря, мы читаем файл развернутого адреса через файловую систему и присваиваем адрес контракта глобальной константе.
Таким же образом мы храним информацию abi в глобальных константах, которые находится в файле deployedabi.
Вернемся к файлу Index.js.
 
 

Итак, помните, что эти две abi и адресная информация, отправленные создателю экземпляра контракта, передаются через глобальные константы, сгенерированные веб-пакетом.
Теперь, когда мы создали пример четырех контрактов, мы продолжим с функцией депозита.
Мы должны кое-что проверить, прежде чем отправлять деньги.
Вы должны убедиться, что вы только что вошли в учетную запись владельца.
Поэтому я должен привести две части информации.
Во-первых, я получаю информацию об учетной записи, зарегистрированной в данный момент.
Во-вторых, я получу переменную состояния владельца, хранящуюся в контракте.
Сначала я получу информацию для входа в систему.
const walletInstance = this.getWallet();

Перейдите к функции getwallet и получите информацию об учетной записи, которая существует в текущем кошельке.
if (cav.klay.accounts.wallet.length) {
      return cav.klay.accounts.wallet[0];
    }

Wallet [0] - это первая учетная запись, добавленная в кошелек, в которую я вошел.
Вы уже завершили реализацию функции.
Далее, давайте назовем значение переменной состояния владельца в контракте.
Перейдите к функции callOwner
return await agContract.methods.owner().call();
 

Мы получим доступ к функции владельца через созданный нами привер контракта на приложение игры и вызовем значение.
Используйте ключевое слово await для асинхронного получения значений.
Поскольку мы сделали необходимые действия до того, как отправим деньги, мы продолжим выполнять функцию депозита.
if (walletInstance) {
 
    }
 

Если экземпляр Wallet существует через функцию getwallet,
то нужно сравнить текущий зарегистрированный адрес учетной записи с адресом учетной записи владельца, полученный из контракта.
if (await this.callOwner() !== walletInstance.address) return; 
 

Если мы сравним их, но значения будут другими, мы больше не продолжаем и завершаем функцию.
 If it is the same
else {
}
 

Получим значение для ввода HTML.
var amount = $('#amount').val();

Если входящее значение существует
if (amount) {
}
 
Отправьте значение в депозитную функцию, используя экземпляр контракта.
 
agContract.methods.deposit().send({
 
})

Сейчас мы отправляем объект транзакции как фактор отправки.
Нам нужно указать три вещи.
Сначала мы должны сказать, кто вызывает эту функцию.
from: walletInstance.address,
 
Я сказал, что мы будем вызывать эту функцию для текущего зарегистрированного аккаунта.
Обратите внимание, что адрес Walletinstance - это учетная запись, которая завершила проверку учетной записи, и она имеет право подписать транзакцию.
Так что я не могу поместить любой адрес в поле «from».
В качестве значения могут использоваться только адреса, которые были проверены в BApp.
И установите потребление газа в пределах 250000.
 
gas: '250000',
 

Поскольку функция депозита в договоре подлежит оплате, вы должны передать поле значения.
value:
 

Мы должны преобразовать число, полученное от ввода html, в peb, который является минимальной единицей KLAY, и передать его.
Преобразуйте его, используя утилиту библиотеки caver.
cav.utils.toPeb(amount, "KLAY")

Теперь вы можете отправлять деньги с помощью функции депозитного контракта.
Но я могу использовать информацию, которая может быть получена асинхронно, вместо завершения транзакции, например
.once('transactionHash', (txHash) => {
    console.log(`txHash: ${txHash}`);
})
 

Во-первых, я могу получить хеш транзакции, и я сделал это видимым на консоли.
Обратите внимание, что оболочка журнала консоли - это не одиночная кавычка, а кавычка слева от цифры 1.
Будьте осторожны.
Далее вы можете получить подтверждение.
.once('receipt', (receipt) => {
   console.log(`(#${receipt.blockNumber})`, receipt);          
})

Получение подтверждения означает, что транзакция была успешно добавлена в блок.
Таким образом, вы можете проверить подтверждение, и увидеть блок, в который была добавлена транзакция.
Если обработка транзакции не удалась, вы можете получить ошибку.
.once('error', (error) => {
   alert(error.message);
  }); 
 

Если есть ошибка, появится сообщение.
Я написал логику, чтобы проверить успех после отправки транзакции.
Наконец, если в html-вводе нет полученной суммы, добавьте оператор return, который завершает функцию.
return;
 

Я завершил этап, которая отправляет KLAY в функцию депозита контракта, и я изменю пользовательский интерфейс и протестирую его в следующем уроке.
 
 
## 5.10 Перевод KLAY по контракту (изменение и тестирование интерфейса)
 
 

Я постараюсь изменить пользовательский интерфейс и провести тестирование.
Когда мы отправили KLAY в функцию депозита в предыдущем курсе и получили подтверждение, транзакция прошла успешно.
Что я должен делать после того, как мне это удалось?
Было бы хорошо, если бы система могла показать мне сообщение с напоминанием.
   alert(amount + " KLAY를 컨트랙에 송금했습니다.");  
 

И я обновлю страницу, чтобы увидеть баланс договора.
   location.reload();     
.

Я сказал, что собираюсь сделать баланс контракта видимым.
Помните, что мы создали функцию, которая загружала бы баланс контракта, когда мы писали смартконтракт.
Мы назовем эту функцию getBalance, она поможет увидеть баланс контракта.
Сначала мы добавим div, который отображает баланс контракта в html.
Перейдите в Index.html и добавьте один div под адресом, который показывает адрес моей учетной записи.
  <div class="text-center" id="contractBalance"></div>

И тогда мы покажем вам баланс контракта здесь.
Теперь, когда представление готово, давайте создадим функцию, которая загружает баланс из серверной части.
Перейдите к функции callcountractbalance и добавьте код.
return await agContract.methods.getBalance().call();
 

Часть, которая обращается к функции getbalance через экземпляр контракта и загружает значение. Да, это было просто.
Откуда я вызываю эту функцию callcountractbalance?
Как мне это назвать?
Если транзакция успешно выполняется в функции депозита и получает подтверждение, она обновляет страницу с помощью location.reload ().
Какова первая функция, которая выполняется при обновлении страницы?
Функция запуска выполняется первой.
Затем мы вызываем функцию changeUI из функции start.
Мне нужно добавить код для загрузки баланса контракта из функции changeUI, которая немедленно меняет интерфейс.
$('#contractBalance').append('<p>' + '이벤트 잔액: ' + cav.utils.fromPeb(await this.callContractBalance(), "KLAY") + ' KLAY' + '</p>');     

Это немного долго.
Я объясню.
Мы добавим сообщение в часть, которая показывает баланс контракта в HTML.
Вызовите функцию callContractBalance, чтобы получить баланс.
Однако баланс загружается в минимальных единицах KLAY, peb.
Это затруднило бы понимание того, сколько осталось, потому что цифра слишком большая.
Так что утилита caver имеет функцию fromPeb.
Это функция, которая может конвертировать из peb в другую единицу.
Я указал второй параметр для преобразования в KLAY.
В результате он показывает сальдо контракта, преобразованное в KLAY в html.
 

Наконец, перевод KLAY в контракт должен быть установлен только для учетной записи владельца.
Вам нужно только дать разрешение организатору процесса.
Поэтому я изменю функцию, чтобы она моглаотображать пользовательский интерфейс, который можно передавать только при входе в систему с учетной записью владельца. Перейдем к функции changeUI
if (await this.callOwner() === walletInstance.address) {
      $("#owner").show(); 
    }     
 
Я установил, чтобы div владельца показывался только тогда, когда адрес учетной записи владельца и адрес зарегистрированной учетной записи совпадают.
В html владелец div по умолчанию установлен невидимым.
Итак, когда вы войдете в систему учетной записью владельца, вы увидите эту часть.
Теперь давайте попробуем протестировать.
Я переустановлю его один раз.
Во-первых, убедитесь, что секретный ключ вашей учетной записи правильно введен в truffle.js.
Я перенесу его из терминала.
‘truffle deploy -compile-all -reset -network klaytn’ Я повторно развернул его для людей, которые его не развернули.
Ваше развертывание окончено.
Давайте проверим это, запустив npm run dev. Нажмите F12, чтобы открыть окно консоли.
Нажмите кнопку Войти
Поскольку вы вошли в свою учетную запись владельца, вы можете увидеть часть, где вы можете отправить деньги.
Давайте  отправим деньги. Отправьте 1 KLAY.
 
 

Вы можете увидеть хэш транзакции и информацию о получении через журнал консоли, если ваша транзакция прошла успешно.
Уведомление работает.
Похоже, что время, необходимое для транзакции, составило менее 3 секунд.
За эти 3 секунды происходит четыре процесса от создания транзакции до создания блока и его распространения в сети после завершения транзакции.
По сравнению с другими блокчейн платформами скорость обработки очень высокая.
Нажмите на уведомление, страница обновится, и сначала будет вызвана функция запуска,
и обновленный баланс контракта, функцией changeUI.
Функция транзакции работает хорошо.
Я хотел бы, чтобы счетчик нагрузки показал, как работает транзакция, хорошо или нет.
Это не является обязательным требованием, но я рекомендую вам сделать это для хорошего пользовательского интерфейса.
Перейдите в Index.js и импортируйте spin.js.
import {Spinner} from 'spin.js';

Перейдите к функции showpinner и сделайте так, чтобы она возвращала экземпляр spinner.
var target = document.getElementById('spin');
    return new Spinner(opts).spin(target);

И вызовите эту функцию из функции депозита.
var spinner = this.showSpinner();
 
После получения подтвержения остановите spinner.
 
  spinner.stop();  

Наконец, добавьте div, чтобы отобразить счетчик в html. Сделайте это под тегом <br/>.
<div id="spin"></div>    
 

Теперь давайте попробуем протестировать.
Да. Когда spinner вращается, появляется подтвержение.
Передаточная функция работает хорошо, а интерфейс хорошо отражается.
Я показал перевод KLAY со счета владельца в контракт.

## 5.11 Генерация случайного числа

Теперь давайте попробуем сделать интересную часть задания.
Давайте создадим два случайных числа, которые будут использоваться для сложения.
Я буду улучшать HTML в первую очередь.
Пожалуйста, добавьте этот код прямо над div.
<div class="row text-center">
        <div id="game" style="display: none;">   
          <div class="yellow-box" id="start">       
            <a href="#" onclick="App.generateNumbers()">시작</a>
          </div>     
          <div class="yellow-box" id="question" style="display: none;">
            <span id="num1"></span> + <span id="num2"></span> = ?          
            <div class="input-group">
              <input type="number" class="form-control" id="answer" />
              <span class="input-group-btn">
                <button type="button" class="btn btn-default" onclick="App.submitAnswer()">제출</button>
              </span>
            </div>
          </div>     
        </div> 
      </div>
<br />
 

Я сделал это невидимым с помощью CSS.
И я сделаю это видимым после того, как войду.
Нажатие на кнопку запуска, она вызывает функцию generateNumbers.
Затем функция сгенерирует два числа: одно для num1 и одно для num2.
Они используются в приложении.
Есть поле ввода, чтобы написать ответ.
Наконец, есть кнопка для отправки ваших ответов.
Простой HTML. Сейчас
я настрою его так, чтобы эту часть могли видеть только пользователи, прошедшие проверку.
Перейдите к функции changeUI и добавьте ее ниже logout.show (), чтобы показать игровой div.
$('#game').show();
 

Теперь давайте проверим это в html.
Если вы вошли в систему, вы можете увидеть приятный интерфейс желтого цвета в середине.
Теперь я установлю числа, которые будут видны при нажатии на кнопку «Пуск».
Давайте создадим случайные числа в функции чисел.
var num1 = Math.random();
 

Сначала мы вызываем случайную функцию класса Math.
Случайная функция случайным образом генерирует число с десятичной точкой меньше 0 и 1.
Но если вы сделаете это, число будет слишком маленьким, поэтому я собираюсь его умножить.
var num1 = Math.random() * 50;
 

Это сгенерирует случайное число от 0 до 49.
Но задача не должна быть слишком простой, поэтому я добавлю 10 к сгенерированному значению, чтобы вы могли генерировать как минимум две цифры.
var num1 = (Math.random() * 50) + 10;
 

Наконец, мы используем функцию floor для отбрасывания десятичной точки.
var num1 = Math.floor((Math.random() * 50) + 10);
 
Если вы сделаете это, у вас будет десятичное число от 10 до 59.
Далее создайте еще одно.
 
var num2 = Math.floor((Math.random() * 50) + 10);
 
Теперь мы будем хранить значения двух чисел в хранилище сессии.
Я сохраню ответ.
 
sessionStorage.setItem('result', num1 + num2);    

Это позже даст правильный ответ, когда пользователь ответит, и попытается сравнить ответы, данные пользователем.
Теперь, когда мы создали числа, мы должны их использовать.
Когда я нажму на Start в html, я скрою это начало и покажу  div ниже. И в то же время я сделаю два числа, сгенерированных функцией, видимыми в полях num1 и num2.
Давайте вернемся к функции и осуществим то, что мы только что сказали.
$('#start').hide();
 

Сделайте начало невидимым.
$('#num1').text(num1);
$('#num2').text(num2);

Пусть система покажет сгенерированные числа в полях num1 и num2.
И пусть это покажет вопрос div.
$('#question').show(); 
	

Наконец, переместите фокус туда, где я пишу ответы, чтобы я мог ответить сразу.
document.querySelector('#answer').focus();

Я проверю это сейчас.
Когда вы нажимаете Пуск, ваши случайные числа генерируются и отображаются в формате HTML.
Вскоре фокус переместился туда, где я пишу ответ.
Это конец сегодняшнего урока, и я постараюсь создать таймер в следующем уроке.

## 5.12  Генерация таймера



Давайте создадим таймер и установим таймаут для задачи сложения на 3 секунды.
  Перейти к HTML и сделать div, который показывает таймер. Я сделаю это прямо под div.
<div class="row text-center">
        <p id="timer"></p>
      </div>   
 
Перейдите к index.js и перейдите к функции showtimer. Здесь мы используем функцию setInterval, ее цель показать число, которое будет отсчитываться. Мы заставим задачу исчезнуть через 3 секунды, и экран вернется к начальному состоянию.
 

Сделайте переменную для сохранения в течение 3 секунд.
$('#timer').text(seconds);

ПРивяжите номер 3 непосредственно к HTML, который показывает таймер.
Я использую функцию setinterval и устанавливаю ее с интервалом в 1 секунду.
  var interval = setInterval(function() {  
  }, 1000);
 

Теперь я могу запустить что-то с интервалом в 1 секунду.
$('#timer').text(--seconds);  
 

Уменьшите числа одно за другим, чтобы они появилось в html.
Теперь значение этой переменной секунды равно 0, то есть, сбросить, когда setinterval равен 0 через 3 секунды.
if (seconds <= 0) {
}     
 
Когда секунд становится 0
 
$('#timer').text('');
 

инициализируйте номер, показывающий часть
     $('#answer').val('');
답적었던input도 초기화시키구요	

Также инициализируйте ввод, на который был дан ответ.
$('#question').hide();
 
Установите div, не показывая задачу. А также,
 
$('#start').show();          
 

Еще раз покажите div, что вы можете нажать старт. В заключение,
  clearInterval(interval);
 

Используйте clearInterval, чтобы остановить время, установленное в setinterval. Да, я создал функцию showtimer. Теперь давайте вызовем эту функцию в функции generateNumbers.
this.showTimer();
 
Если вы сделаете это, то как только вы нажмете Пуск, будет создан таймер и начнется обратный отсчет. Давайте попробуем проверить.
Нажмите на Пуск. Ниже будет сгенерирован таймер и начнется обратный отсчет в течение 3 секунд. Через 3 секунды он сбрасывается.
Итак, я создал таймер.
 
 
 
## 5.13 Отправка ответов и получение KLAY
 
Это последний урок. Если пользователь отправляет ответ и ответ правильный, давайте реализуем часть, которая отправляет KLAY на учетную запись пользователя из контракта. Перейдите к функции submitAnswer. Загрузите значение правильного ответа, которое хранится в хранилище сеанса.
const result = sessionStorage.getItem('result');
 

И сохраните ответы, которые дал пользователь в переменных.
var answer = $('#answer').val();  
 

Теперь проведите сравнение.
if (answer === result) { }
 

Если пользователь дал правильный ответ, нажмите кнопку подтверждения при открытии окна сообщения подтверждения и отправьте пользователю KLAY.
if (confirm("대단하네요^^ 0.1 KLAY 받기")) { }
 

Если пользователь нажал кнопку «ОК», перед отправкой убедитесь, что баланс в контракте составляет не менее 0,1 KLAY.
if (await this.callContractBalance() >= 0.1) { }

Если это так, вызовите функцию receiveKlay.
this.receiveKlay();
 

Если не существует, отправьте уведомление.
else { alert("죄송합니다. 컨트랙의 KLAY가 다 소모되었습니다."); }    
 

Наконец, если пользователь не дал правильный ответ, отправьте уведомление.
else { alert("땡! 초등학생도 하는데 ㅠㅠ"); }
 
 
 

Да, функция submitanswer реализовала.
Давайте проверим это один раз.
Это сообщение отображается, если ответ неправильный.
Когда это будет сделано, появится окно подтверждения сообщения для получения KLAY.
Когда вы нажмете OK, вы вызовете функцию receiveklay для передачи KLAY.
Я еще не реализовал это.
Давайте реализуем функцию.
Это наша последняя функция.
 
Когда пользователь дает правильный ответ, он оплачивает транзакцию через свой аккаунт и получает KLAY.
Мы преобразуем 0,1 KLAY в нашей передаточной функции контракта в peb и передадим это в качестве аргумента.
Во-первых, давайте покажем вам, как загружать процесс, используя спиннер во время обработки транзакций.
var spinner = this.showSpinner();

Кроме того, нам нужен проверенный адрес учетной записи, необходимый для транзакции, поэтому загрузите экземпляр кошелька.
const walletInstance = this.getWallet();
 

Если значение экземпляра кошелька не существует, выйдите из функции.
if (!walletInstance) return;  
 

Если существует, используйте экземпляр контракта для доступа к передаточной функции в контракте.
agContract.methods.transfer().send({
})
 
Передаточная функция контракта получает один аргумент.
Вам нужно использовать утилиту caver, чтобы преобразовать KLAY в peb и передать его.
 
cav.utils.toPeb(“0.1”, "KLAY")
 
И вы сказали, что вам нужно отправить объект транзакции в параметре отправки.
Вам необходимо указать, кто вызывает эту функцию и сколько составит ограничение по газу.
 
from: walletInstance.address,
gas: '250000'
 
Передайте экземпляр кошелька, адрес, подтвержденный вашим аккаунтом, и потребление газа в пределах 250 000.
Обратите внимание, что поле value не является обязательным.
Я не буду передавать value, потому что передаточная функция не является payable типом.
Если вы сделаете это, вы подтвердити все суммы, которые будут переданы.
Теперь, после обработки транзакции, вы должны проверить, была ли она успешной или нет.
Я мог проверить, удалось ли это (депозит) или нет через это - .once.
Однако есть и другой способ.
Я могу получить подтверждение, используя promise.
 
.then(function (receipt) {
});     

Подождите и получите значение подтврждения.
if (receipt.status) { }

В объекте подтверждения есть поле с именем status.
Если оно true, транзакция передана успешно.
Так что, если вам удалась транзакция, остановите spinner.
spinner.stop(); 

 
Также покажите уведомления
alert("0.1 KLAY가 " + walletInstance.address + " 계정으로 지급되었습니다.");      
 

Кроме того, давайте создадим ссылку в html, чтобы обработанная транзакция могла быть проверена непосредственно из интерфейса.
Я собираюсь создать новый div.
Я сделаю это под таймером div.
<div class="row text-center">
   <div id="transaction"></div>
</div>  

<br />
 

Вы увидите ссылку в этом разделе.
Вернитесь к функции и сначала очистите div транзакции.
    $('#transaction').html("");
 

Я очищаю транзакцию div, чтобы показывать новую ссылку каждый раз, когда транзакция создается.
Далее я добавлю ссылку.
    $('#transaction')
      .append(`<p><a href='https://baobab.klaytnscope.com/tx/${receipt.txHash}' 
                   target='_blank'>클레이튼 Scope에서 트랜젝션 확인</a></p>`);
 
 
В подтверждаении, возвращаемом promise,
найдите поле транзакции в параметре url сайта KlaytnScope, чтобы увидеть только что обработанную информацию о транзакции.
Наконец, покажите последний обновленный баланс контракта в html.
 
return agContract.methods.getBalance().call()
  .then(function (balance) {
});        
 
Вызовите функцию getBalance контракта, чтобы показать остаток в контракте.
 
 $('#contractBalance').html("");          
 

Очищает существующее отображение показанного баланса и немедленно показывает обновленный баланс.
$('#contractBalance').append('<p>' + '이벤트 잔액: ' + cav.utils.fromPeb(balance, "KLAY") + ' KLAY' + '</p>');           
 
Пока весь процесс завершен.
Теперь давайте попробуем протестировать.
На этот раз я пытаюсь войти в систему  другой учетной записью, а не учетной записью владельца.
Вы можете продолжить с учетной записи владельца.
Если вы создали другую учетную запись, вы также можете попробовать ее.
 
Если вы решили задачу и нажали кнопку OK, вызывается функция receiveKlay.
Отображается уведомление, и транзакция была успешно завершена.
Вы можете закрыть уведомление и увидеть, что ваш баланс уменьшен.
Баланс в договоре был уменьшен, поскольку он перемещается на ваш счет.
И внизу была создана ссылка.
Если вы нажмете на ссылку, вы увидите информацию о пути, который мы только что создали в интрфейсе.
Нажмите на адрес своей учетной записи, и вы увидите, что баланс вырос.
Итак, мы решили задачу и перенесли KLAY в контракте на свой счет.

